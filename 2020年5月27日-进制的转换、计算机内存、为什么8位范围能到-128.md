## 进制的转换、计算机内存、为什么8位范围能到-128

#### 1. 进制的转换

**十进制转二进制**

10 转 二进制

10 / 2 = 5 --- 0

5 / 2 = 2 ----- 1

2 / 2 = 1 ----- 0

1 / 2 = 0 ----- 1

把上面的余数从下向上数， 1010。就是二进制的10

**二进制转十进制**

1010 转 十进制

0 * （2的0次方）= 0

1 * （2的1次方）= 2

0 * （2的2次方）= 0

1 * （2的3次方）= 8

然后相加 2 + 8 = 10

#### 2. 计算机内存占用大小

1byte（1字节） = 8bit（8位）

1kb = 1024byte

1mb = 1024kb

1gb = 1024mb

**在java中，整数范围 **

- 操作系统16位的时候，int 2字节，操作系统32位的时候，int 4字节，由于32位系统之前占主流地位，实际现在就算是64位系统，出于兼容性考虑，int也是4字节的（网上解释）

| 类型  | 字节 | 位数 | 范围                                       |
| ----- | ---- | ---- | ------------------------------------------ |
| byte  | 1    | 1*8  | -128 ~ 127                                 |
| int   | 4    | 4*8  | -2147483648 ~ 2147483647                   |
| short | 2    | 2*8  | -32768 ~ 32767                             |
| long  | 8    | 8*8  | -9223372036854775808 ~ 9223372036854775807 |

**浮点类型**

| 类型   | 字节 | 位数 | 范围                              |
| ------ | ---- | ---- | --------------------------------- |
| float  | 4    | 4*8  | 1.4E-45 ~ 3.4028235E38            |
| double | 8    | 8*8  | 4.9E-324 ~ 1.7976931348623157E308 |

**字符类型**

| 类型 | 字节 | 位数 | 范围     |
| ---- | ---- | ---- | -------- |
| char | 2    | 2*8  | 打印乱码 |

**boolean类型**

| 类型    | 字节 | 位数 | 范围     |
| ------- | ---- | ---- | -------- |
| boolean | 1    | 1*8  | 打印乱码 |

#### 3. 为什么8位有符号类型的数值范围是-128~127

对于有符号类型，计算机在处理的时候会把最高位当做符号位，0表示正数，1表示负数。举例来说（以下举例均针对8位有符号数）：

*0000 0001*即为*1*，*1000 0001*即为*-1*，那么很容易得到8位有符号数值的表示范围应该是*1111 1111* ~ *0111 1111*，也就是*-127*~*127*，问题来了，*-128*是怎么来的呢？

| 整数 | 符号位（0正数，1负数） | 其他位   |
| ---- | ---------------------- | -------- |
| 1    | 0                      | 000 0001 |
| -1   | 1                      | 000 0001 |

**解决为什么会出现 -128需要知道前置知识**

```
原码：是一种计算机中对数字的二进制定点表示方法。原码表示法在数值前面增加了一位符号位（即最高位为符号位）：正数该位为0，负数该位为1（0有两种表示：+0和-0），其余位表示数值的大小。
```

```
反码：正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。
```

```
补码：正数的补码与其原码相同；负数的补码等于其反码+1。
```

| 整数              | 原码       | 反码       | 补码（负数，反码基础加1） |
| ----------------- | ---------- | ---------- | ------------------------- |
| 1（正数三者一致） | 0 000 0001 | 0 000 0001 | 0 000 0001                |
| -1（负数则不同）  | 1 000 0001 | 1 111 1110 | 1 111 1111                |

**在开始，举例就是用的原码，符合人的逻辑思维。**

**但是在计算机中，原码处理就很麻烦了，例如 1 + -1**

```
1 		   + -1         = 0
人主观逻辑相加是错误的，很明显这样相加是不行的，所以计算机要用源码处理很复杂
0 000 0001 + 1 000 0001 = 1 000 0010
```

**用补码的方式，能得到正确结果**

```
如果用补码的话（超出位的舍弃），这样就对了。为什么补码可以，之后在研究
0 000 0001 + 1 111 1111 = 0 000 0000
```

**回到最开始的问题，8位有符号数值的最小值为什么是-128而不是-127呢，我们列出来部分原码、反码和补码的对照表看看：**

| 整数 | 原码       | 反码       | 补码       |
| ---- | ---------- | ---------- | ---------- |
| 127  | 0 111 1111 | 0 111 1111 | 0 111 1111 |
| 126  | 0 111 1110 | 0 111 1110 | 0 111 1110 |
| ...  | ...        | ...        | ...        |
| 1    | 0 000 0001 | 0 000 0001 | 0 000 0001 |
| 0    | 0 000 0000 | 0 000 0000 | 0 000 0000 |
| 0    | 1 000 0000 | 1 000 0000 | 1 000 0000 |
| -1   | 1 000 0001 | 1 111 1110 | 1 111 1111 |
| -2   | 1 000 0010 | 1 111 1101 | 1 111 1110 |
| ...  | ...        | ...        | ...        |
| -126 | 1 111 1110 | 1 000 0001 | 1 000 0010 |
| -127 | 1 111 1111 | 1 000 0000 | 1 000 0001 |
| -128 | 无法表示   | 无法表示   | 1 000 0000 |

**这个表格中和 -128补码相同的，只有0的其中一种情况。0采用`0 000 0000` 标识 -128 `1 000 0000` 表示这样就没有冲突了，所以范围能到 -128 **